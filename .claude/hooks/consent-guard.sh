#!/bin/bash
# ============================================================
# consent-guard.sh - 合意プロセス強制フック
# ============================================================
# 発火条件: PreToolUse:Edit/Write
# 目的: ユーザーとの合意なしで Edit/Write をブロック
#
# 【設計意図】
# Claude がユーザープロンプトを「良かれと思って省略」し、
# 意図しない大規模変更を行う問題を構造的に防止する。
#
# 【フロー】
# 1. ユーザープロンプト受信
# 2. LLM が [理解確認] ブロックを出力
# 3. ユーザーが OK/修正/却下 を選択
# 4. OK の場合のみ consent ファイルを削除
# 5. consent ファイルがない場合のみ Edit/Write 許可
#
# M082: Hook 契約準拠（必ず理由を出力、パース失敗時は INTERNAL ERROR）
# 参照: docs/hook-exit-code-contract.md
# ============================================================

# -e を外す（エラーでも処理を続けて理由を出力するため）
set -uo pipefail

HOOK_NAME="consent-guard"

# ============================================================
# リポジトリルート取得（portable化）
# ============================================================
REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null || pwd)

# ============================================================
# Admin モードチェック（M079: コア契約は回避不可）
# ============================================================
STATE_FILE="${REPO_ROOT}/state.md"
# admin モードでも consent チェックは維持
# CLAUDE.md Core Contract: タスク開始時の合意プロセスは回避不可
# 注: consent ファイルが存在しない場合は通過するため、実質的な影響は最小

# ============================================================
# 設定（リポジトリルートから相対パス）
# ============================================================
CONSENT_DIR="${REPO_ROOT}/.claude/.session-init"
CONSENT_FILE="${CONSENT_DIR}/consent"

# ============================================================
# jq チェック
# ============================================================
if ! command -v jq &> /dev/null; then
    echo "[SKIP] $HOOK_NAME: jq command not found" >&2
    exit 0
fi

# ============================================================
# 入力解析
# ============================================================
INPUT=$(cat) || {
    echo "[INTERNAL ERROR] $HOOK_NAME: failed to read input" >&2
    exit 0
}

TOOL_NAME=$(echo "$INPUT" | jq -r '.tool_name // empty' 2>/dev/null) || {
    echo "[INTERNAL ERROR] $HOOK_NAME: JSON parse failed" >&2
    exit 0
}

# ============================================================
# 対象ツールチェック
# ============================================================
case "$TOOL_NAME" in
    Edit|Write)
        # 合意チェック対象
        ;;
    *)
        # 対象外ツールは通過
        echo "[SKIP] $HOOK_NAME: not Edit/Write tool ($TOOL_NAME)" >&2
        exit 0
        ;;
esac

# ============================================================
# 合意ファイル存在チェック（pending 方式）
# ============================================================
# consent ファイルが存在する = 未合意（pending）→ ブロック
# consent ファイルが存在しない = 合意済み → 通過
#
# フロー:
#   1. session-start.sh が consent ファイルを作成（pending 状態）
#   2. [理解確認] 出力 → ユーザー OK
#   3. consent ファイルを削除（合意済み）
#   4. Edit/Write が許可される
# ============================================================
if [ -f "$CONSENT_FILE" ]; then
    echo "[BLOCK] $HOOK_NAME: consent file exists, user agreement required" >&2
    cat << 'EOF'

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  [理解確認] - 合意プロセス未完了
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Edit/Write を実行する前に、以下の [理解確認] ブロックを
  出力し、ユーザーの合意を得てください。

  フォーマット:
    [理解確認]
    what: 「〇〇をすること」と理解しました
    why: 目的は「△△」と推測します
    how: 以下の手順で進めます
    scope: 変更対象ファイル
    exclusions: 変更しないファイル
    risks: |
      リスク1_{カテゴリ}:
        問題: {失敗の可能性}
        影響: {影響度}
        対策: {防止策}

  ユーザーが「OK」「了解」「はい」等と応答すると、
  prompt-guard.sh が自動的に consent を削除します。

  対応パターン: OK, 了解, はい, 進めて, yes, お願い 等

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
EOF
    exit 2
fi

# ============================================================
# 合意済み（consent ファイルが存在しない）- 通過
# ============================================================
echo "[PASS] $HOOK_NAME: consent file not found, proceeding" >&2
exit 0
